
//And I was with you in weakness, and in fear, and in much trembling. (1Cor 2:3)

http://info.javarush.ru/JavaRush_lectures_discussion/2013/10/20/%D0%9B%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-25.html





/*
Уровень 25: план уровня и доп. материалы
 Обсуждение лекций
 лекция
План уровня:
Enum, все особенности
Thread Life Cycle, состояние объекта Thread
Все нюансы создания и запуска новой нити, демоны.
Все нюансы прерывания/остановки нитей
Стек вызовов и перехват ошибок
Другие методы класса Thread (sleep, yield...)

Курс Java

Что еще можно посмотреть на досуге:
Ответы на вопросы к собеседованию по теме уровня.

Еще несколько полезных материалов по enumeration
О многопоточности в Java

Пособие для будущего Java разработчика. Enterprise — часть 1 

www.youtube.com/playlist?list=PL6jg6AGdCNaXo06LjCBmRao-qJdf38oKp


Нашли классную ссылку к материалу данной темы? Добавьте ее сюда в виде комментария.
Возможно, именно Ваша ссылка поможет другому человеку стать программистом и улучшить свою жизнь!

Вернуться к плану обучения 

Вернуться к обучению java онлайн на JavaRush
—
0
16 комментариев 
 Oska
Oska 22 сентября 2015, 14:34 0
Рекомендую видео Юрия Ткача Advanced Java — Concurrency
Очень доступно и понятно подается материал.
 DefNeo
DefNeo 12 августа 2016, 20:33 0 ↑
Да да, очень полезна лекция у него))) Очень понравилось
 ab_random
ab_random 28 февраля 2016, 18:44 0
С Хабра: Обзор java.util.concurrent.*.
И еще: Многопоточность в Java: ExecutorService
Интересная статья по сокетам: Программирование сокетов на Java
 remain4life
remain4life 8 мая 2016, 10:48 0
На 14-м уроке то же видео, что и на 10-м уровне, только почему-то в более плохом качестве :) Можно было бы что-то новенькое включить.
 OctoTad
OctoTad 5 июня 2016, 07:54 0
В своё время эта статья помогла разобраться с блокировками и перехватом InterruptedException.
 paNNo4ka
paNNo4ka 27 ноября 2016, 14:19 0 ↑ Комментарий отредактирован 2016-11-27 14:19:54 пользователем paNNo4ka
Интересная статья, спасибо. Правда, мне показалось, что в оригинале понятнее написано:)
 OctoTad
OctoTad 10 июня 2016, 16:56 0
Кто-нибудь может подсказать КАК работает метод isAlive() «под капотом», а не ЧТО он делает? Единственное что нашел, это исходный код из пакета java.util.Thread, это:

public final native boolean isAlive();

Может где-то ещё посмотреть нужно?
 OctoTad
OctoTad 16 июня 2016, 11:18 0 ↑
Мне тут подсказали где искать реализацию. Этот метод нужно искать в исходниках JVM, но посмотрев исходники понял, что ничего не понял))
 alexand
alexand 1 августа 2016, 14:08 0
Остался не понятным метод yield().
Описание из лекции:
yield() – текущая нить «пропускает свой ход». Нить из состояния running переходит в состояние ready, а Java-машина приступает к выполнению следующей нити. Состояния running & ready – это подсостояния состояния RUNNABLE.
Вот что по этому поводу у Эккеля написано:
Если вы знаете, что в текущей итерации run() сделано все необходимое, вы можете подсказать механизму планирования потоков, что процессором теперь может воспользоваться другой поток. Эта подсказка (не более чем рекомендация; нет никакой гарантии, что планировщик потоков «прислушается» к ней) воплощается в форме вызова метода yield(). Вызывая yield(), вы сообщаете системе, что в ней могут выполняться другие потоки того же приоритета.

Моя версия JVM подтверждает версию именно Эккеля. Более того, вторая задача 11 лекции вообще не так работает как ожидает валидатор. Ошибка в лекции?
 Yuri_0504
Yuri_0504 7 ноября 2016, 19:04 0 ↑
11-я задача работает правильно. Проблема в том, что System.out, System.in и System.err — это нейтивные потоки ОС и println() пишет в буфер ОС, а уже сама операционная система решает в какой последовательности выводить в консоль.
 DefNeo
DefNeo 12 августа 2016, 22:39 0
Видео повторяется.
 Nicson777
Nicson777 11 октября 2016, 01:04 0
С какого уровня следует начинать знакомиться с enterprise?
 Evgenym
Evgenym 16 февраля 2017, 16:31 0
Вот тут небольшая обзорная полезная статья о многопоточности.
 Corwin
Corwin 10 апреля 2017, 14:42 0 Комментарий отредактирован 2017-04-10 14:43:32 пользователем Corwin
Иллюстрация из данной ссылки думаю будет более точная.
 apollox
apollox 11 мая 2017, 10:34 0
У меня есть непонятка с ENUM.
По лекции, 
public enum Direction
{
UP, 
DOWN,
LEFT,
RIGHT,
}
компилятором преобразуется в примерно это:
public final class Direction extends Enum
{
public static final Direction UP = new Direction(); 
public static final Direction DOWN = new Direction();
public static final Direction LEFT = new Direction();
public static final Direction RIGHT = new Direction();

private Direction() {} //приватный конструктор
}
Тут все понятно.
У нас есть статические переменные, в каждой из которых хранится ссылка на объект Direction.

А непонятно вот что.
Приватный конструктор Direction должен вызвать конструктор суперкласса, т.е. енума.
Но у него есть только конструктор с параметрами: 
protected Enum(String name, int ordinal) {
this.name = name;
this.ordinal = ordinal;
}
А это значит, что мы должны в нашем конструкторе вызвать конструктор суперкласса с параметрами, но этого нет…
И непонятно, как каждый из объектов new Direction() получает названия констант (UP и так далее), как они передаются? Т.е как допустим первый new Direction() получает в name ENUM'a этот самый «UP», который мы можем позже вывести переопределенным toString()?
*/
